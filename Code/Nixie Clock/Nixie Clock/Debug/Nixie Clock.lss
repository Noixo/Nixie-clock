
Nixie Clock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004e0  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  00000554  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000001  00802000  00802000  00000554  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000554  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000584  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000130  00000000  00000000  000005c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003fcd  00000000  00000000  000006f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002eb3  00000000  00000000  000046c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001147  00000000  00000000  00007574  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000290  00000000  00000000  000086bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001f7b  00000000  00000000  0000894c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000095c  00000000  00000000  0000a8c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e0  00000000  00000000  0000b223  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 fe 00 	jmp	0x1fc	; 0x1fc <__ctors_end>
   4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
   8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
   c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  10:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  14:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  18:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  1c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  20:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  24:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  28:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  2c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  30:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  34:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  38:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  3c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  40:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  44:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  48:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  4c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  50:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  54:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  58:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  5c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  60:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  64:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  68:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  6c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  70:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  74:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  78:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  7c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  80:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  84:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  88:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  8c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  90:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  94:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  98:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  9c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  a0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  a4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  a8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  ac:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  b0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  b4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  b8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  bc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  c0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  c4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  c8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  cc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  d0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  d4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  d8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  dc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  e0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  e4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  e8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  ec:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  f0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  f4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  f8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
  fc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 100:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 104:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 108:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 10c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 110:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 114:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 118:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 11c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 120:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 124:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 128:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 12c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 130:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 134:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 138:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 13c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 140:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 144:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 148:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 14c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 150:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 154:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 158:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 15c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 160:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 164:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 168:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 16c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 170:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 174:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 178:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 17c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 180:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 184:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 188:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 18c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 190:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 194:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 198:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 19c:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1a0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1a4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1a8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1ac:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1b0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1b4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1b8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1bc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1c0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1c4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1c8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1cc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1d0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1d4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1d8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1dc:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1e0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1e4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1e8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1ec:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1f0:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1f4:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>
 1f8:	0c 94 1b 01 	jmp	0x236	; 0x236 <__bad_interrupt>

000001fc <__ctors_end>:
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf ef       	ldi	r28, 0xFF	; 255
 202:	cd bf       	out	0x3d, r28	; 61
 204:	df e2       	ldi	r29, 0x2F	; 47
 206:	de bf       	out	0x3e, r29	; 62

00000208 <__do_copy_data>:
 208:	10 e2       	ldi	r17, 0x20	; 32
 20a:	a0 e0       	ldi	r26, 0x00	; 0
 20c:	b0 e2       	ldi	r27, 0x20	; 32
 20e:	e0 ee       	ldi	r30, 0xE0	; 224
 210:	f4 e0       	ldi	r31, 0x04	; 4
 212:	02 c0       	rjmp	.+4      	; 0x218 <__do_copy_data+0x10>
 214:	05 90       	lpm	r0, Z+
 216:	0d 92       	st	X+, r0
 218:	a0 30       	cpi	r26, 0x00	; 0
 21a:	b1 07       	cpc	r27, r17
 21c:	d9 f7       	brne	.-10     	; 0x214 <__do_copy_data+0xc>

0000021e <__do_clear_bss>:
 21e:	20 e2       	ldi	r18, 0x20	; 32
 220:	a0 e0       	ldi	r26, 0x00	; 0
 222:	b0 e2       	ldi	r27, 0x20	; 32
 224:	01 c0       	rjmp	.+2      	; 0x228 <.do_clear_bss_start>

00000226 <.do_clear_bss_loop>:
 226:	1d 92       	st	X+, r1

00000228 <.do_clear_bss_start>:
 228:	a1 30       	cpi	r26, 0x01	; 1
 22a:	b2 07       	cpc	r27, r18
 22c:	e1 f7       	brne	.-8      	; 0x226 <.do_clear_bss_loop>
 22e:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <main>
 232:	0c 94 6e 02 	jmp	0x4dc	; 0x4dc <_exit>

00000236 <__bad_interrupt>:
 236:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000023a <initDisplay>:
	// clear pins 5-7
	sendData(0x07, 1);
	
	//write data to pins 5-7
	sendData(byte,0);
}
 23a:	8f ef       	ldi	r24, 0xFF	; 255
 23c:	80 93 40 06 	sts	0x0640, r24	; 0x800640 <__TEXT_REGION_LENGTH__+0x700640>
 240:	97 e0       	ldi	r25, 0x07	; 7
 242:	90 93 60 06 	sts	0x0660, r25	; 0x800660 <__TEXT_REGION_LENGTH__+0x700660>
 246:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
 24a:	8f e0       	ldi	r24, 0x0F	; 15
 24c:	80 93 20 06 	sts	0x0620, r24	; 0x800620 <__TEXT_REGION_LENGTH__+0x700620>
 250:	80 e1       	ldi	r24, 0x10	; 16
 252:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <__TEXT_REGION_LENGTH__+0x700661>
 256:	08 95       	ret

00000258 <characterTube>:
missing
n	set pinm 2 & 3 high pin 3 = PIN4, pin 2 is 16
*/

void characterTube(unsigned char byte)
{
 258:	cf 93       	push	r28
 25a:	c8 2f       	mov	r28, r24
	
	//PORTC.OUTSET = PIN4_bm;
	//sendData(0x18,1);
	//sendData(0x10, 0);
	
	PORTC.OUTCLR = PIN5_bm;
 25c:	e0 e4       	ldi	r30, 0x40	; 64
 25e:	f6 e0       	ldi	r31, 0x06	; 6
 260:	80 e2       	ldi	r24, 0x20	; 32
 262:	86 83       	std	Z+6, r24	; 0x06
	PORTC.OUTCLR = PIN4_bm;
 264:	80 e1       	ldi	r24, 0x10	; 16
 266:	86 83       	std	Z+6, r24	; 0x06
	sendData(0x18,1);
 268:	61 e0       	ldi	r22, 0x01	; 1
 26a:	88 e1       	ldi	r24, 0x18	; 24
 26c:	0e 94 30 02 	call	0x460	; 0x460 <sendData>
	
	
	if(byte & 0x02)
 270:	c1 ff       	sbrs	r28, 1
 272:	03 c0       	rjmp	.+6      	; 0x27a <characterTube+0x22>
		PORTC.OUTSET = PIN5_bm;
 274:	80 e2       	ldi	r24, 0x20	; 32
 276:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
		
		
	if((byte & 0x04) || (byte & 0x08))
 27a:	c2 fd       	sbrc	r28, 2
 27c:	02 c0       	rjmp	.+4      	; 0x282 <characterTube+0x2a>
 27e:	c3 ff       	sbrs	r28, 3
 280:	06 c0       	rjmp	.+12     	; 0x28e <characterTube+0x36>
	{
		//send to 2 for 0x08, send to pin 4 for 0x04
			sendData((byte & 0x0C) << 1, 0);
 282:	60 e0       	ldi	r22, 0x00	; 0
 284:	8c 2f       	mov	r24, r28
 286:	8c 70       	andi	r24, 0x0C	; 12
 288:	88 0f       	add	r24, r24
 28a:	0e 94 30 02 	call	0x460	; 0x460 <sendData>
	}
	
		
	if(byte & 0x01)	//pin 3
 28e:	c0 ff       	sbrs	r28, 0
 290:	03 c0       	rjmp	.+6      	; 0x298 <characterTube+0x40>
		PORTC.OUTSET = PIN4_bm;
 292:	80 e1       	ldi	r24, 0x10	; 16
 294:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
		
	//PORTC.OUTSET = PIN4_bm; = k
	//PORTC.OUTSET = PIN5_bm; = blank
	
	//sendData(1 << 3, 0);
}
 298:	cf 91       	pop	r28
 29a:	08 95       	ret

0000029c <rtc_init>:
	}
	time[i] = bcdToDec(i2c_read(1));	//set to not ack when 6th loop
	
	i2c_stop();
	return time;
}
 29c:	e0 e6       	ldi	r30, 0x60	; 96
 29e:	f6 e0       	ldi	r31, 0x06	; 6
 2a0:	80 e2       	ldi	r24, 0x20	; 32
 2a2:	82 83       	std	Z+2, r24	; 0x02
 2a4:	88 e1       	ldi	r24, 0x18	; 24
 2a6:	85 8b       	std	Z+21, r24	; 0x15
 2a8:	08 95       	ret

000002aa <rtc_ctrl>:

void rtc_ctrl(unsigned char mask)
{	
 2aa:	cf 93       	push	r28
 2ac:	c8 2f       	mov	r28, r24
	i2c_start();
 2ae:	0e 94 79 01 	call	0x2f2	; 0x2f2 <i2c_start>
	
	i2c_device_id(ds3231, 0);
 2b2:	60 e0       	ldi	r22, 0x00	; 0
 2b4:	88 e6       	ldi	r24, 0x68	; 104
 2b6:	0e 94 8f 01 	call	0x31e	; 0x31e <i2c_device_id>
	
	i2c_write(CONTROL);
 2ba:	8e e0       	ldi	r24, 0x0E	; 14
 2bc:	0e 94 de 01 	call	0x3bc	; 0x3bc <i2c_write>
	
	//i2c_start();
	//i2c_device_id(ds3231, 1);
	i2c_write(mask);
 2c0:	8c 2f       	mov	r24, r28
 2c2:	0e 94 de 01 	call	0x3bc	; 0x3bc <i2c_write>
	
	i2c_stop();
 2c6:	0e 94 84 01 	call	0x308	; 0x308 <i2c_stop>
}
 2ca:	cf 91       	pop	r28
 2cc:	08 95       	ret

000002ce <init_i2c>:
	//SDA = last_byte;
	
	i2c_clock();
	
	return byte;
}
 2ce:	e1 e8       	ldi	r30, 0x81	; 129
 2d0:	f6 e0       	ldi	r31, 0x06	; 6
 2d2:	91 e0       	ldi	r25, 0x01	; 1
 2d4:	90 83       	st	Z, r25
 2d6:	82 e0       	ldi	r24, 0x02	; 2
 2d8:	80 83       	st	Z, r24
 2da:	e0 e8       	ldi	r30, 0x80	; 128
 2dc:	f6 e0       	ldi	r31, 0x06	; 6
 2de:	95 83       	std	Z+5, r25	; 0x05
 2e0:	85 83       	std	Z+5, r24	; 0x05
 2e2:	08 95       	ret

000002e4 <i2c_clock>:
 2e4:	e0 e8       	ldi	r30, 0x80	; 128
 2e6:	f6 e0       	ldi	r31, 0x06	; 6
 2e8:	82 e0       	ldi	r24, 0x02	; 2
 2ea:	85 83       	std	Z+5, r24	; 0x05
 2ec:	00 00       	nop
 2ee:	86 83       	std	Z+6, r24	; 0x06
 2f0:	08 95       	ret

000002f2 <i2c_start>:
 2f2:	e0 e8       	ldi	r30, 0x80	; 128
 2f4:	f6 e0       	ldi	r31, 0x06	; 6
 2f6:	91 e0       	ldi	r25, 0x01	; 1
 2f8:	95 83       	std	Z+5, r25	; 0x05
 2fa:	82 e0       	ldi	r24, 0x02	; 2
 2fc:	85 83       	std	Z+5, r24	; 0x05
 2fe:	00 00       	nop
 300:	96 83       	std	Z+6, r25	; 0x06
 302:	00 00       	nop
 304:	86 83       	std	Z+6, r24	; 0x06
 306:	08 95       	ret

00000308 <i2c_stop>:
 308:	e0 e8       	ldi	r30, 0x80	; 128
 30a:	f6 e0       	ldi	r31, 0x06	; 6
 30c:	92 e0       	ldi	r25, 0x02	; 2
 30e:	96 83       	std	Z+6, r25	; 0x06
 310:	81 e0       	ldi	r24, 0x01	; 1
 312:	86 83       	std	Z+6, r24	; 0x06
 314:	00 00       	nop
 316:	95 83       	std	Z+5, r25	; 0x05
 318:	00 00       	nop
 31a:	85 83       	std	Z+5, r24	; 0x05
 31c:	08 95       	ret

0000031e <i2c_device_id>:
 31e:	ef 92       	push	r14
 320:	ff 92       	push	r15
 322:	0f 93       	push	r16
 324:	1f 93       	push	r17
 326:	cf 93       	push	r28
 328:	df 93       	push	r29
 32a:	00 d0       	rcall	.+0      	; 0x32c <i2c_device_id+0xe>
 32c:	cd b7       	in	r28, 0x3d	; 61
 32e:	de b7       	in	r29, 0x3e	; 62
 330:	89 83       	std	Y+1, r24	; 0x01
 332:	6a 83       	std	Y+2, r22	; 0x02
 334:	89 81       	ldd	r24, Y+1	; 0x01
 336:	88 30       	cpi	r24, 0x08	; 8
 338:	a8 f1       	brcs	.+106    	; 0x3a4 <i2c_device_id+0x86>
 33a:	89 81       	ldd	r24, Y+1	; 0x01
 33c:	89 37       	cpi	r24, 0x79	; 121
 33e:	a0 f5       	brcc	.+104    	; 0x3a8 <i2c_device_id+0x8a>
 340:	17 e0       	ldi	r17, 0x07	; 7
 342:	10 c0       	rjmp	.+32     	; 0x364 <i2c_device_id+0x46>
 344:	89 81       	ldd	r24, Y+1	; 0x01
 346:	88 0f       	add	r24, r24
 348:	89 83       	std	Y+1, r24	; 0x01
 34a:	89 81       	ldd	r24, Y+1	; 0x01
 34c:	88 23       	and	r24, r24
 34e:	24 f4       	brge	.+8      	; 0x358 <i2c_device_id+0x3a>
 350:	81 e0       	ldi	r24, 0x01	; 1
 352:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
 356:	03 c0       	rjmp	.+6      	; 0x35e <i2c_device_id+0x40>
 358:	81 e0       	ldi	r24, 0x01	; 1
 35a:	80 93 86 06 	sts	0x0686, r24	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>
 35e:	0e 94 72 01 	call	0x2e4	; 0x2e4 <i2c_clock>
 362:	11 50       	subi	r17, 0x01	; 1
 364:	11 11       	cpse	r17, r1
 366:	ee cf       	rjmp	.-36     	; 0x344 <i2c_device_id+0x26>
 368:	8a 81       	ldd	r24, Y+2	; 0x02
 36a:	81 30       	cpi	r24, 0x01	; 1
 36c:	19 f4       	brne	.+6      	; 0x374 <i2c_device_id+0x56>
 36e:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
 372:	03 c0       	rjmp	.+6      	; 0x37a <i2c_device_id+0x5c>
 374:	81 e0       	ldi	r24, 0x01	; 1
 376:	80 93 86 06 	sts	0x0686, r24	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>
 37a:	0e 94 72 01 	call	0x2e4	; 0x2e4 <i2c_clock>
 37e:	0f 2e       	mov	r0, r31
 380:	f0 e8       	ldi	r31, 0x80	; 128
 382:	ef 2e       	mov	r14, r31
 384:	f6 e0       	ldi	r31, 0x06	; 6
 386:	ff 2e       	mov	r15, r31
 388:	f0 2d       	mov	r31, r0
 38a:	01 e0       	ldi	r16, 0x01	; 1
 38c:	f7 01       	movw	r30, r14
 38e:	02 83       	std	Z+2, r16	; 0x02
 390:	05 83       	std	Z+5, r16	; 0x05
 392:	80 85       	ldd	r24, Z+8	; 0x08
 394:	18 2f       	mov	r17, r24
 396:	11 70       	andi	r17, 0x01	; 1
 398:	0e 94 72 01 	call	0x2e4	; 0x2e4 <i2c_clock>
 39c:	f7 01       	movw	r30, r14
 39e:	01 83       	std	Z+1, r16	; 0x01
 3a0:	81 2f       	mov	r24, r17
 3a2:	03 c0       	rjmp	.+6      	; 0x3aa <i2c_device_id+0x8c>
 3a4:	82 e0       	ldi	r24, 0x02	; 2
 3a6:	01 c0       	rjmp	.+2      	; 0x3aa <i2c_device_id+0x8c>
 3a8:	82 e0       	ldi	r24, 0x02	; 2
 3aa:	0f 90       	pop	r0
 3ac:	0f 90       	pop	r0
 3ae:	df 91       	pop	r29
 3b0:	cf 91       	pop	r28
 3b2:	1f 91       	pop	r17
 3b4:	0f 91       	pop	r16
 3b6:	ff 90       	pop	r15
 3b8:	ef 90       	pop	r14
 3ba:	08 95       	ret

000003bc <i2c_write>:

void i2c_write(unsigned char byte)
{
 3bc:	cf 93       	push	r28
 3be:	df 93       	push	r29
 3c0:	d8 2f       	mov	r29, r24
	char i;
	for(i = 8; i > 0; i--)
 3c2:	c8 e0       	ldi	r28, 0x08	; 8
 3c4:	0d c0       	rjmp	.+26     	; 0x3e0 <i2c_write+0x24>
	{
		//bit shifts data by i and ANDs it to convert it to boolean
		if((byte & 0x80))
 3c6:	dd 23       	and	r29, r29
 3c8:	24 f4       	brge	.+8      	; 0x3d2 <i2c_write+0x16>
			SDA_HIGH;
 3ca:	81 e0       	ldi	r24, 0x01	; 1
 3cc:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
 3d0:	03 c0       	rjmp	.+6      	; 0x3d8 <i2c_write+0x1c>
		else
			SDA_LOW;
 3d2:	81 e0       	ldi	r24, 0x01	; 1
 3d4:	80 93 86 06 	sts	0x0686, r24	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>
		//SDA = byte & 0x80;	//Sends a 1 or 0 to SDA
		
		//pulse the clock
		i2c_clock();
 3d8:	0e 94 72 01 	call	0x2e4	; 0x2e4 <i2c_clock>
		
		byte <<= 1;
 3dc:	dd 0f       	add	r29, r29
}

void i2c_write(unsigned char byte)
{
	char i;
	for(i = 8; i > 0; i--)
 3de:	c1 50       	subi	r28, 0x01	; 1
 3e0:	c1 11       	cpse	r28, r1
 3e2:	f1 cf       	rjmp	.-30     	; 0x3c6 <i2c_write+0xa>
		
		byte <<= 1;
	}
	
	//set to high to detect ack bit
	SDA_HIGH;
 3e4:	81 e0       	ldi	r24, 0x01	; 1
 3e6:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
	
	i2c_clock();
 3ea:	0e 94 72 01 	call	0x2e4	; 0x2e4 <i2c_clock>

}
 3ee:	df 91       	pop	r29
 3f0:	cf 91       	pop	r28
 3f2:	08 95       	ret

000003f4 <main>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 3f4:	2f e3       	ldi	r18, 0x3F	; 63
 3f6:	8d e0       	ldi	r24, 0x0D	; 13
 3f8:	93 e0       	ldi	r25, 0x03	; 3
 3fa:	21 50       	subi	r18, 0x01	; 1
 3fc:	80 40       	sbci	r24, 0x00	; 0
 3fe:	90 40       	sbci	r25, 0x00	; 0
 400:	e1 f7       	brne	.-8      	; 0x3fa <main+0x6>
 402:	00 c0       	rjmp	.+0      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
 404:	00 00       	nop
{
	
	const unsigned char time[7] = {00,0x12,0x20,1,1,1,1};
	_delay_ms(500);	//delay to let voltage stabalise
	
	initDisplay();
 406:	0e 94 1d 01 	call	0x23a	; 0x23a <initDisplay>
	
	initShiftReg();
 40a:	0e 94 63 02 	call	0x4c6	; 0x4c6 <initShiftReg>
	init_i2c();
 40e:	0e 94 67 01 	call	0x2ce	; 0x2ce <init_i2c>
	rtc_init();
 412:	0e 94 4e 01 	call	0x29c	; 0x29c <rtc_init>
	
	// set square wave to 1Hz, enable squarewave output
	rtc_ctrl(0x00);
 416:	80 e0       	ldi	r24, 0x00	; 0
 418:	0e 94 55 01 	call	0x2aa	; 0x2aa <rtc_ctrl>
	
	sendData(LAMPHH | LAMPMM, 0);
 41c:	60 e0       	ldi	r22, 0x00	; 0
 41e:	80 ec       	ldi	r24, 0xC0	; 192
 420:	0e 94 30 02 	call	0x460	; 0x460 <sendData>

	//rtc_set_time(time);
	unsigned char i = 0;
 424:	c0 e0       	ldi	r28, 0x00	; 0
		
		//if( a > 20000 && a < 30000)
	//	{
		//	cathodeRefresh();
	//	}
		if(PORTD.IN & PULSE)
 426:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <__TEXT_REGION_LENGTH__+0x700668>
 42a:	85 ff       	sbrs	r24, 5
 42c:	fc cf       	rjmp	.-8      	; 0x426 <__LOCK_REGION_LENGTH__+0x26>
		{
			
			characterTube(i);
 42e:	8c 2f       	mov	r24, r28
 430:	0e 94 2c 01 	call	0x258	; 0x258 <characterTube>
			i = (i + 1) % 0x10;
 434:	8c 2f       	mov	r24, r28
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	01 96       	adiw	r24, 0x01	; 1
 43a:	8f 70       	andi	r24, 0x0F	; 15
 43c:	90 78       	andi	r25, 0x80	; 128
 43e:	99 23       	and	r25, r25
 440:	24 f4       	brge	.+8      	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
 442:	01 97       	sbiw	r24, 0x01	; 1
 444:	80 6f       	ori	r24, 0xF0	; 240
 446:	9f 6f       	ori	r25, 0xFF	; 255
 448:	01 96       	adiw	r24, 0x01	; 1
 44a:	c8 2f       	mov	r28, r24
 44c:	2f ef       	ldi	r18, 0xFF	; 255
 44e:	80 e7       	ldi	r24, 0x70	; 112
 450:	92 e0       	ldi	r25, 0x02	; 2
 452:	21 50       	subi	r18, 0x01	; 1
 454:	80 40       	sbci	r24, 0x00	; 0
 456:	90 40       	sbci	r25, 0x00	; 0
 458:	e1 f7       	brne	.-8      	; 0x452 <__LOCK_REGION_LENGTH__+0x52>
 45a:	00 c0       	rjmp	.+0      	; 0x45c <__LOCK_REGION_LENGTH__+0x5c>
 45c:	00 00       	nop
 45e:	e3 cf       	rjmp	.-58     	; 0x426 <__LOCK_REGION_LENGTH__+0x26>

00000460 <sendData>:
void sendData(unsigned char byte, unsigned char bit)
{
	unsigned char i;
	static unsigned char last_command;	// keeps track of set bits in shift register
	
	if(bit)
 460:	66 23       	and	r22, r22
 462:	41 f0       	breq	.+16     	; 0x474 <sendData+0x14>
	{
		/* invert byte then AND with the last_command, preserving contents of 
		last_command so only set pins become cleared*/
		last_command &= ~byte;
 464:	80 95       	com	r24
 466:	90 91 00 20 	lds	r25, 0x2000	; 0x802000 <__data_end>
 46a:	89 23       	and	r24, r25
 46c:	80 93 00 20 	sts	0x2000, r24	; 0x802000 <__data_end>
				
	E.G.	sendData(0x01, 0) turns ON the 8th bit of the shift register
			sendData(0x01, 1) clears the 8th bit in the shift register
*/
void sendData(unsigned char byte, unsigned char bit)
{
 470:	20 e0       	ldi	r18, 0x00	; 0
 472:	1d c0       	rjmp	.+58     	; 0x4ae <sendData+0x4e>
		byte = last_command;	//byte is destructive, so copy
	}
	else
	{
		//copy byte data into last_command
		last_command |= byte;
 474:	90 91 00 20 	lds	r25, 0x2000	; 0x802000 <__data_end>
 478:	98 2b       	or	r25, r24
 47a:	90 93 00 20 	sts	0x2000, r25	; 0x802000 <__data_end>
	
		//copy last_commands data back into byte
		byte |= last_command;
 47e:	89 2b       	or	r24, r25
 480:	f7 cf       	rjmp	.-18     	; 0x470 <sendData+0x10>
	}
	
	// send byte to shift register, Big-endian
	for (i = 0; i < 8; i++)
	{
		if((byte & 0x01))	//read first bit
 482:	80 ff       	sbrs	r24, 0
 484:	03 c0       	rjmp	.+6      	; 0x48c <sendData+0x2c>
			PORTE.OUTSET = SHIFTDATA;	//Set DATA pin to HIGH
 486:	98 e0       	ldi	r25, 0x08	; 8
 488:	90 93 85 06 	sts	0x0685, r25	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
			
		PORTD.OUTSET = SHIFTCLK;	//set CLK pin to HIGH
 48c:	e0 e6       	ldi	r30, 0x60	; 96
 48e:	f6 e0       	ldi	r31, 0x06	; 6
 490:	98 e0       	ldi	r25, 0x08	; 8
 492:	95 83       	std	Z+5, r25	; 0x05
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 494:	33 e0       	ldi	r19, 0x03	; 3
 496:	3a 95       	dec	r19
 498:	f1 f7       	brne	.-4      	; 0x496 <sendData+0x36>
 49a:	00 00       	nop
		_delay_us(10);
		
		PORTE.OUTCLR = SHIFTDATA;	//Set DATA pin to LOW
 49c:	90 93 86 06 	sts	0x0686, r25	; 0x800686 <__TEXT_REGION_LENGTH__+0x700686>
		PORTD.OUTCLR = SHIFTCLK;	//set CLK pin to LOW
 4a0:	96 83       	std	Z+6, r25	; 0x06
 4a2:	93 e0       	ldi	r25, 0x03	; 3
 4a4:	9a 95       	dec	r25
 4a6:	f1 f7       	brne	.-4      	; 0x4a4 <sendData+0x44>
 4a8:	00 00       	nop
		_delay_us(10);
		
		byte >>= 1;	// shift all bits down, removing first bit
 4aa:	86 95       	lsr	r24
		//copy last_commands data back into byte
		byte |= last_command;
	}
	
	// send byte to shift register, Big-endian
	for (i = 0; i < 8; i++)
 4ac:	2f 5f       	subi	r18, 0xFF	; 255
 4ae:	28 30       	cpi	r18, 0x08	; 8
 4b0:	40 f3       	brcs	.-48     	; 0x482 <sendData+0x22>
		_delay_us(10);
		
		byte >>= 1;	// shift all bits down, removing first bit
	}
	// tell shift register to activate
	PORTE.OUTSET = LATCH;
 4b2:	e0 e8       	ldi	r30, 0x80	; 128
 4b4:	f6 e0       	ldi	r31, 0x06	; 6
 4b6:	84 e0       	ldi	r24, 0x04	; 4
 4b8:	85 83       	std	Z+5, r24	; 0x05
 4ba:	33 e0       	ldi	r19, 0x03	; 3
 4bc:	3a 95       	dec	r19
 4be:	f1 f7       	brne	.-4      	; 0x4bc <sendData+0x5c>
 4c0:	00 00       	nop
	_delay_us(10);
	PORTE.OUTCLR = LATCH;
 4c2:	86 83       	std	Z+6, r24	; 0x06
 4c4:	08 95       	ret

000004c6 <initShiftReg>:
#include <avr/io.h>
#include <util/delay.h>

void initShiftReg()
{
	PORTD.DIRSET = SHIFTCLK;	//set SHIFTCLK pin to output
 4c6:	88 e0       	ldi	r24, 0x08	; 8
 4c8:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <__TEXT_REGION_LENGTH__+0x700661>
	PORTE.DIRSET = LATCH | SHIFTDATA;	//set SHIFTCLK pin to output
 4cc:	8c e0       	ldi	r24, 0x0C	; 12
 4ce:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
	sendData(0xFF, 1);	// ensure shift register is in known state
 4d2:	61 e0       	ldi	r22, 0x01	; 1
 4d4:	8f ef       	ldi	r24, 0xFF	; 255
 4d6:	0e 94 30 02 	call	0x460	; 0x460 <sendData>
 4da:	08 95       	ret

000004dc <_exit>:
 4dc:	f8 94       	cli

000004de <__stop_program>:
 4de:	ff cf       	rjmp	.-2      	; 0x4de <__stop_program>
